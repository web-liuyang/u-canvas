<script lang="ts" setup>
import { ref } from "vue";
import {
	//
	ICTapEvent,
	ICTouchcancelEvent,
	ICTouchendEvent,
	ICTouchmoveEvent,
	ICTouchstartEvent,
	ICZoominEvent,
	ICZoomoutEvent,
	TouchInfo,
	resolveTouchInfo,
} from "./event";

const props = defineProps<{ id: string }>();

const emit = defineEmits<{
	(e: "onTap", event: ICTapEvent): void;
	(e: "onTouchstart", event: ICTouchstartEvent): void;
	(e: "onTouchmove", event: ICTouchmoveEvent): void;
	(e: "onTouchend", event: ICTouchendEvent): void;
	(e: "onTouchcancel", event: ICTouchcancelEvent): void;
	(e: "onZoomin", event: ICZoominEvent): void;
	(e: "onZoomout", event: ICZoomoutEvent): void;
}>();

const PRESS_TIMEOUT = 200;

const pressing = ref(false);
const moving = ref(false);

const onTapTimestamp = ref(0);
const onTapTimer = ref<number>();

const onSetTimeout = (handler: TimerHandler, timeout?: number) => {
	onTapTimer.value = setTimeout(handler, timeout);
};

const onClearTimeout = () => {
	if (onTapTimer.value) {
		clearTimeout(onTapTimer.value);
		onTapTimer.value = undefined;
	}
};

// 在模拟事件时，事件系统并没有返回足够的信息
// 所以需要缓存上一个 事件信息，以便统一返回
const eventState = ref<UniTouchEvent>();
// 用于计算 move 偏移量
const originTouchInfo = ref<TouchInfo>();

const onTouchstart = (e: UniTouchEvent) => {
	e.preventDefault();
	pressing.value = true;
	onTapTimestamp.value = Date.now();
	eventState.value = e;

	onClearTimeout();
	onSetTimeout(() => {
		// console.log("A")
		const touchInfo = resolveTouchInfo(e);
		emit("onTouchstart", new ICTouchstartEvent(touchInfo));
		moving.value = true;
		originTouchInfo.value = touchInfo;
	}, PRESS_TIMEOUT);
};

const onTouchmove = (e: UniTouchEvent) => {
	e.preventDefault();
	if (pressing.value && !moving.value) {
		onClearTimeout();
		const touchInfo = resolveTouchInfo(e);
		emit("onTouchstart", new ICTouchstartEvent(touchInfo));
		moving.value = true;
		originTouchInfo.value = touchInfo;
	} else if (moving.value) {
		const uniTouch = resolveTouchInfo(e);
		const [deltaX, deltaY] = [uniTouch.x - originTouchInfo.value!.x, uniTouch.y - originTouchInfo.value!.y];

		emit("onTouchmove", new ICTouchmoveEvent({ ...uniTouch, deltaX, deltaY }));
		eventState.value = e;
	}
};

const onTouchend = (e: UniTouchEvent) => {
	e.preventDefault();

	if (Date.now() - onTapTimestamp.value < PRESS_TIMEOUT && !moving.value) {
		const uniTouch = resolveTouchInfo(eventState.value ?? e);
		emit("onTap", new ICTapEvent(uniTouch));
		onClearTimeout();
	} else if (pressing.value && moving.value) {
		const uniTouch = resolveTouchInfo(eventState.value ?? e);
		emit("onTouchend", new ICTouchendEvent(uniTouch));
	}

	pressing.value = false;
	moving.value = false;
	eventState.value = undefined;
	originTouchInfo.value = undefined;
};

const onTouchcancel = (e: UniTouchEvent) => {
	e.preventDefault();
	const uniTouch = resolveTouchInfo(eventState.value ?? e);
	emit("onTouchcancel", new ICTouchcancelEvent(uniTouch));
	pressing.value = false;
	moving.value = false;
};

const onWheel = (e: WheelEvent) => {
	const sign = Math.sign(e.deltaY);
	if (sign === 0) return;
	const uniTouch = resolveTouchInfo(e);
	if (sign < 0) {
		emit("onZoomin", new ICZoominEvent(uniTouch));
	} else {
		emit("onZoomout", new ICZoomoutEvent(uniTouch));
	}
};
</script>

<template>
	<!-- @vue-expect-error -->
	<canvas
		:id="props.id"
		@mousedown="onTouchstart"
		@mousemove="onTouchmove"
		@mouseup="onTouchend"
		@wheel="onWheel"
		@touchstart="onTouchstart"
		@touchmove="onTouchmove"
		@touchend="onTouchend"
		@touchcancel="onTouchcancel"
	/>
</template>
